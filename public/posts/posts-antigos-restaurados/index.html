<!--
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

- -->
<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="shrink-to-fit=no,width=device-width,height=device-height,initial-scale=1,user-scalable=1"><meta name=description content="My corner of the web"><title>Adler Medrado's corner of the web</title><link rel=author href=/humans.txt><link rel=canonical href=https://adlermedrado.com.br><link href=/css/styles.css rel=stylesheet></head><body><header><nav class=navbar role=navigation><div class=navbar_left><a href=/><strong>Adler Medrado's corner of the web</strong></a></div><div class=navbar_right><a href=/posts>Posts</a>
<a href=/tags>Posts by Tags</a></div></nav></header><main><section class=section><article><div><h1>Posts antigos restaurados</h1><div><div><p><small><time>December 31, 2017</time>
|
4 minutes read</small></p></div><span class=line_break></span></div><div class=content><p>É muito legal ser programador e participar de projetos com as mais variadas dimensões e complexidades, mas uma das
coisas que eu acho mais legal em ser um programador é o fato de poder utilizar este conhecimento para automatizar
tarefas e resolver problemas do cotidiano.</p><p>Resolvi escrever este post justamente porque eu automatizei uma tarefa que me tomaria algumas horas com um pequeno e
simples script <a href=https://www.python.org/>python</a>.</p><p>Eu achei legal escrever um pouco sobre isso porque pode servir de exemplo para pessoas que não trabalham com programação
diariamente de que elas podem se beneficiar em conhecer um pouco e tentar otimizar tarefas repetitivas.</p><h3 id=contextualizando>Contextualizando</h3><p><a href=https://github.com/adlermedrado-archive/dangolino>No início de 2012 eu implementei um projeto pessoal para poder gerar meu blog com páginas estáticas</a>,
estilo Jekyl, Pelican, etc., mas muito mais simples pois foi feito para atender somente as minhas necessidades.</p><p>Eu implementei também um pequeno importador para converter meu blog <a href=https://wordpress.com/>wordpress</a> neste novo
formato. Tudo funcionou legal, e usei durante um bom tempo, mas passaram-se uns anos e eu precisei trocar de computador
e achei um saco atualizar todas as libs necessárias para o projeto funcionar, então eu voltei para o wordpress.</p><p>Quando eu voltei ao Wordpress eu deixei alguns desses posts antigos para trás, não os publiquei novamente e eles ficaram
num backup para até um dia em que eu tivesse paciência, publica-los novamente. E então passaram-se alguns anos.</p><p>Recentemente eu passei a utilizar o <a href=https://blog.getpelican.com/>pelican</a>, que é um gerador de sites estáticos e ontem
eu me lembrei dos posts antigos que estavam nos meus backups e decidi que era a oportunidade de importa-los novamente.</p><p>O problemas é que isso me daria muito trabalho, e uma das coisas que programador menos gosta é de ficar fazendo trabalho
braçal, então, tentei automatizar o processo.</p><h3 id=a-solução>A solução</h3><p>Exisitiam em torno de 200 posts, imagina copiar isso um a um manualmente, editar e salvar no formato do Pelican no
diretório correto? <em>No way</em>.</p><p>A primeira coisa que eu fiz foi analisar se quando eu gerei os arquivos estáticos (HTML), eu o fiz deixando-os
padronizados, mas nem todos estavam dentro do mesmo padrão. <em>Shame on me</em>, lição aprendida, bola pra frente.</p><p>Eu salvei todos os arquivos HTML em um diretório chamado <em>old</em> e os posts estavam salvos da seguinte maneira:</p><pre><code>|\_\_\_\_old   
| |\_\_\_\_2010   
| | |\_\_\_\_04   
| | | |\_\_\_\_arquivos html
</code></pre><p>Não coloquei toda a árvore aqui para não ficar muito grande, mas basicamente os arquivos estavam agrupados por <strong>ANO</strong> e <strong>MÊS</strong>, então para processa-los eu precisei iterar no diretório <em>old</em> e seus subdiretórios:</p><pre><code>for subdir, dirs, files in os.walk(content\_root):   
for file in files: if 'images' not in subdir:   
with open(file\_path, 'r') as content\_file:   
</code></pre><h1 id=converte-o-arquivo>converte o arquivo</h1><p>O diretório <em>old</em> tem um subdiretório chamado images e eu não processei o que tinha dentro dele justamente por só conter
imagens.</p><p>O próximo passo foi fazer o parse do HTML para poder trabalhar com o texto, para isso eu usei a biblioteca
BeautifoulSoup:</p><pre><code>def extract\_data():   
content = content\_file.read()   
soup = BeautifulSoup(content, &quot;html.parser&quot;)   
post\_title = soup.html.body.h1.text   
post\_content\_data = soup.findAll('div', {'class': 'span12'})\[1\]  
post\_date = post\_content\_data.find('p').text.replace('Post date:', '').strip()   
if not post\_date:   
raise ValueError(&quot;Post date not found&quot;)   
post\_content = post\_content\_data.text.strip()   
post\_content = re.sub(r'Post date: (d+/d+/d+)', '', post\_content)   
post\_content = re.sub(r'- (d+:d+:d+)', '', post\_content)  
post\_slug = file.replace('.html', '')

return {   
'post\_title': replace\_invalid\_chars(post\_title),  
'post\_date': post\_date, 'post\_content':         replace\_invalid\_chars(post\_content),   
'post\_slug': replace\_invalid\_chars(post\_slug),   
}
</code></pre><p>Esta função basicamente obtinha as informações do post que eu precisava (titulo, data, slug e conteúdo) e fazia alguns
tratamentos nestes dados, porque eu não me lembro o motivo, mas muitos caracteres estavam incorretos.</p><p>Eu também removi trechos de texto desnecessários, removi espaços em branco das extremidades e coisas simples assim, essa
função retorna um dicionário com as informações necessárias para salvar o novo arquivo.</p><p>Na sequência eu uma função que criava o novo arquivo markdown, adicionava nele o conteúdo no formato do Pelican e o
salva:</p><pre><code>def convert\_to\_new\_post(post\_contents):   
info\_message = '\*\*AVISO:\*\* \_Este post é muito antigo e seu conteúdo provavelmente está defasado, '  'permanecendo
no meu blog apenas por motivos históricos.\_nn'   
new\_post\_file = f&quot;converted/{post\_contents\['post\_slug'\]}.md&quot;  
new\_post = open(new\_post\_file, 'w')   
new\_post.write(f&quot;Title: {post\_contents\['post\_title'\]}n&quot;)  
new\_post.write(f&quot;Date: {post\_contents\['post\_date'\]}n&quot;)  
new\_post.write(&quot;Author: adlern&quot;) new\_post.write(&quot;Tags: oldn&quot;)  
new\_post.write(f&quot;Slug: {post\_contents\['post\_slug'\]}n&quot;)  
new\_post.write(&quot;Status: publishednn&quot;)   
new\_post.write(info\_message + post\_contents\['post\_content'\])  
new\_post.close()
</code></pre><h3 id=nem-todos-os-posts-foram-importados>Nem todos os posts foram importados</h3><p>No final eu descartei alguns posts pois eles eram contextualmente irrelevantes para o site, e apesar de eu não gostar de
jogar história fora, aqueles eram tão bobinhos que sinceramente, não farão muita falta.</p><p>Mas eles estão salvos aqui, para caso eu mude de idéia algum dia.</p><h3 id=código-completo-e-considerações-finais>Código completo e considerações finais</h3><p>Se eu não tivesse criado este script eu teria que fazer esse processo manualmente em duas centenas de arquivos e
certamente não seria algo agradável e eu levei algo em torno de 30 minutos para escreve-lo.</p><p>O código completo está <a href=https://gist.github.com/adlermedrado/6159cbf6b3fcca2473c175816f7ff94f>salvo em um Gist</a> a quem
interessar possa.</p></div></div></article><div><div><div><a href=https://adlermedrado.com.br/posts/do-php-ao-python/>&#8592; Do PHP ao Python</a>
|
<a href=https://adlermedrado.com.br/posts/enabling-click-and-drag-on-macbook/>Enabling Click and Drag on MacBook &#8594;</a></div></div></div></section></main><span class=line_break></span>
<span class=line_break></span><footer><div><p><small>&copy; 1996-2023 Adler Medrado</small></p></div><div class=gpg_signed_info><p>All pages on this website are PGP signed.
Import my <a href=/pub-key.asc>public key</a> and check with <em>curl https://adlermedrado.com.br/posts/posts-antigos-restaurados/ | gpg --verify</em></p></div></footer></body></html><!--
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEEXZd8hNji/2MRgqvhKWCEk4dBO2AFAmSGO8sACgkQKWCEk4dB
O2D0ZhAAnHE/4v8nJ9m8MistA6dQ0/vTQu9G1Op3Q14IKcPORcjJuUtsrZt8Hqqo
6Sok7hFRCprAne6ziJH7Os3Hajdh5ipJAHKm4j+Ow9VgqBH5Y/doQpNFAH4Vj9mg
iGuEAksE/8gLFsJwT9xy4wTYV1LfJR6fPYfVZrflTdCJfD/UvkQ7IDXJs6iSlHvQ
AlC/261qLFSApCAKaixacp4bUZmEHJ3abVk9L/qj24Pq2R6HiPRgDgGS/uHO1M9R
z+nvRyWVX7LIj0hVlpWiNlxOcFcc+AxId9c2SV+jF8fs+nKPtscI+e5ZvDS9KqtF
7R+DbLznR2lT+AL3e4TMx7Ie0V4fIXVTS2aq0plRrgxQbDfXrwJI3Jwhw841aaHz
l1BQV2E+d0jZG9jDnEgJQPtp/jg+xbP3dsj0CS0bIfgSgoGHHsi1HjrVzDwib7y6
BrAkHNOYCw0ZkHbRAhP5Qi0KU+W3HoYguLSJkqvofGwK+qycMyKWQk40lfjlwuQJ
ToC7v1mDK2a3c38u04NDxz9dsyjbQAZXhmyXFbr3+NI3Iuq5nn1zExquTEX18UNC
4XV3wAmIRUGSAiNQsKmknQFiVtQHrXJYFz4swxxImRPvr/6YXoADRuSTg9C3HFf2
SjEzoLlh9UGHlIqdp/GkIcZDtjOcSMxSZtUKccIPKFxbrC/s7u0=
=himJ
-----END PGP SIGNATURE-----
-->
